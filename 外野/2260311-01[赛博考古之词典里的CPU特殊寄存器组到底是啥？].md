
*****

####  泰坦失足  
##### 1#       楼主       发表于 2025-8-27 07:55

.cronclosethread_getbox{border: 1px dashed #FF9A9A;padding:6px 8px;line-height: 24px;margin: 10px 0;font-size: 12px;overflow:hidden;color: #CA4312;}

此帖将于2025-09-26 07:47自动关闭

现在在谷歌里面搜"special register groups" cpu, 排在前面的结果已经都是报道这件事的新闻了, 连谷歌AI快速解答都能正确回答. 当然这个幽灵依然到处徘徊, 时不时会在某个奇怪的角落出现, 比如 CMS80F761x Series Reference Manual

Google AI Search: “特殊寄存器组”是一个过时且在很大程度上不准确的 CPU 寄存器术语，它因被纳入 1960 年对 CPU 的定义而流行开来，并且尽管它只是某一台大型机（Honeywell 800）的特性，却一直延续至今。在 Honeywell 800 中，“特殊寄存器组”是为八个并发运行的程序各自设置的一组独立寄存器。如今，CPU 使用通用寄存器来存放数据和操作数，并使用特殊用途寄存器（如 Program Counter、Flag Register 和 Stack Pointer）来执行特定功能，而不是为多个程序设置“组”。

来源: [https://www.righto.com/2019/10/h ... groups-invaded.html](https://www.righto.com/2019/10/how-special-register-groups-invaded.html)

“特殊寄存器组”如何在数十年间侵入计算机词典

半个世纪前，令人困惑的短语“special register groups”开始出现在“CPU”的定义中，直到今天仍然如此。在这篇博文中，我揭示了“special register groups”如何从 Honeywell 800 大型机中的一个鲜为人知的功能，一路出现在《**》中。

在研究老式计算机时，我发现一个关于“Central Processing Unit”的奇怪定义在不同来源中反复出现。摘自 2017 年再版的一本书：

中央处理器（CPU）—计算机系统的一部分，包含主存储器、算术单元以及 special register groups。它执行算术运算，控制指令处理，并提供定时信号。

乍一看，这一定义似乎没问题，但稍加思索就会发现一些问题。存储器不是 CPU 的一部分。更令人困惑的是，什么是 special register groups？CPU 有寄存器，但“special register groups”并不是一个常见的表述。

事实证明，这一定义在过去半个多世纪里被广泛使用，尽管它并不合理，在不同来源之间被不断复制和修改。special register groups 是 Honeywell 800 大型机（于 1959 年推出）中的一个特性。尽管这台计算机早已被人遗忘，但它的影响却莫名其妙地留存在许多术语表中。Honeywell 800 允许在单个处理器上运行八个程序，每执行一条指令后就在程序之间切换。为了支持这一点，每个程序在硬件中都有一个“special register group”，即其各自独立的一组 32 个寄存器（程序计数器、通用寄存器、变址寄存器等）。

霍尼韦尔 800 计算机。中央处理单元（包含 special register groups）位于沿墙放置的高 6 英尺、宽 18 英尺的机柜中。卡片读卡器和打印机位于房间中央。典型系统的租金为每月 25,000 美元。

关于那个时代需要注意的另一件重要事情是，中央处理单元是一个大型的物理机箱，也被称为“main frame”。（当时 mainframe 还不是一种计算机类型。）因此，鉴于霍尼韦尔 800 的特性，霍尼韦尔词汇表中对 CPU 的定义完全说得通。不幸的是，当用于一般计算机时，这一定义就不合理了，因为它们没有 special register groups。

霍尼韦尔对 main frame 的定义：“计算机系统的中央处理器。它包含主存储器、算术单元和 special register groups。与 CPU 和 central processing unit 同义。（2）计算机中除输入、输出、外设以及在某些情况下存储单元之外的所有部分。”

这个定义显然始于美国农业部在 1960 年发布的《ADP 术语词汇表》：“MAIN FRAME——计算机系统的中央处理器。它包含主存储器、算术单元和 special register groups。”随后该定义在政府系统中传播。预算局在 1962 年出版了《自动数据处理词汇表》，供“政府行政部门的所有官员和雇员作为权威参考使用”。空军在 1966 年的《自动数据处理系统审计指南》中使用了类似的定义，海军在 1966 年的《机器会计员培训课程》和空军在 1968 年的《通信-电子术语手册》中也采用了类似表述。

从那时起，这一定义传播到数十本书籍和词典中。“special register groups”出现在众多计算机术语表中，例如《计算术语词汇表》（1972）、《医学与健康科学计算机词汇表》（1973）、《工程师与科学家的计算机词汇表》（1973）、Radio Shack 的《电子学词典》（1968，1974-1975）以及《计算机图形学词汇表》（1983）。

Radio Shack 1974-1975 年新版《Dictionary of Electronics》包含如下定义：“central processing unit——也称 central processor。计算机系统的一部分，包含主存储器、算术单元和特殊寄存器组。执行算术运算，控制指令处理，并提供定时信号和其他维护操作。”

计算机制造商本该知道他们的系统没有“特殊寄存器组”，但他们仍然沿用了这一定义。例如，Sphere microcomputer（1976）、Texas Instruments（1978）、Cray（1984）、Convergent Technologies（1987）和 Tektronix（1989）。

即使进入了微型计算机时代，这一定义仍然存在，尽管存储显然已不再属于 CPU 的一部分，而“特殊寄存器组”早已成为过去。1983 年 MICRO 杂志的 Beginners’s Computer Glossary 中定义了 CPU，依旧包括 special register groups。它也出现在 Microcomputer Dictionary（1981）和 Understanding Microprocessors（1984）中。

诸如《Computer Technology in the Health Sciences》（1974）、《College Typewriting》（1975）、《Research Methods for Recreation and Leisure》（1979）、EPA 的《Design Automation Handbook for Automation of Activated Sludge Treatment Plants》（1980）、Patrick-Turner 的《Industrial Automation Dictionary》（1996）、《Video Scrambling &amp; Descrambling》（1998）、美国交通部的《Computerized Signal Systems》（1979）以及《Traffic Control System Operations》（2000）等书籍中，也都出现了这一表述。

1981 年，“special register groups”登上了《Washington Post》的词汇表。到了 2006 年，甚至《National Fire Code》也收录了“special register groups”。

“特殊寄存器组”仍在教授给下一代学生。以下测验题来自一本 2017 年的计算机组织与程序设计教材：

CPU of a computer system does not contain:

(a) Main storage

(b) Arithmetic unit

(c) Special register group

(d) None of the above

结论

由于某种原因，1960 年对“central processing unit”的定义包含了“特殊寄存器组”，这是来自 Honeywell 800 大型机的一个晦涩特性。这个定义在随后几十年里被不断复制和修改，尽管它并不合情理。看来一旦某个说法出现在权威术语表中，人们就会沿用数十年，而过时的术语可能永远不会消失。

对这个短语的研究也显示计算机术语的含义如何随着时间发生巨大转变。1960 年，“main frame”和“CPU”是同义词，但从那以后它们朝相反方向发展：“mainframe”如今指大型计算机系统，而“CPU”通常是处理器芯片。

﹍﹍﹍

评分

 参与人数 2战斗力 0

|昵称|战斗力|理由|
|----|---|---|
| oyss| + 1|好评加鹅|
| saizeriya|-1|aigc|

查看全部评分

*****

####  革萌  
##### 2#       发表于 2025-8-27 08:00

赛博咬文嚼字<img src="https://static.stage1st.com/image/smiley/face2017/001.png" referrerpolicy="no-referrer">

*****

####  gammatau  
##### 3#       发表于 2025-8-27 09:06

honeywell还造过主机的吗

*****

####  就咋的  
##### 4#       发表于 2025-8-27 09:44

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327094&amp;ptid=2260311" target="_blank">gammatau 发表于 2025-8-27 09:06</a>

honeywell还造过主机的吗</blockquote>
从航空航天到消费产品

*****

####  Herreimu  
##### 5#       发表于 2025-8-27 09:50

按文中的逻辑，所有计算机硬件术语都得扔

*****

####  就咋的  
##### 6#       发表于 2025-8-27 10:09

<img src="https://img.stage1st.com/forum/202508/27/100753zy2thsslls922xzx.png" referrerpolicy="no-referrer">

<strong>102721836-05-01-acc_页面_03.png</strong> (1.87 MB, 下载次数: 0)

下载附件

2025-8-27 10:07 上传

<img src="https://img.stage1st.com/forum/202508/27/100806s4lpzd53594uoqgs.png" referrerpolicy="no-referrer">

<strong>102721836-05-01-acc_页面_12.png</strong> (467.6 KB, 下载次数: 0)

下载附件

2025-8-27 10:08 上传

<img src="https://img.stage1st.com/forum/202508/27/100818ze09z69r99p35zju.png" referrerpolicy="no-referrer">

<strong>102721836-05-01-acc_页面_13.png</strong> (768.05 KB, 下载次数: 0)

下载附件

2025-8-27 10:08 上传

[https://archive.computerhistory. ... 21836-05-01-acc.pdf](https://archive.computerhistory.org/resources/access/text/2021/11/102721836-05-01-acc.pdf)

*****

####  henvelleng  
##### 7#       发表于 2025-8-27 10:17

有点莫名其妙，主存储器就一定是在cpu外面吗？内部集成的ram不可以吗？外部存储器是要初始化后才能用的，内部是上电直接可用的。特殊功能寄存器往往是和cpu版本有关，影响架构相关代码的移植的

*****

####  Jet.Black  
##### 8#       发表于 2025-8-27 10:17

这文是AI生成的？

早些年嵌入式单片机不是很常见么，

编译时加载个带汇编的头文件，

能访问些特殊寄存器搞点特殊功能什么的。

非要扯上上古时期的大型机，这才是故意污染语义。

*****

####  unlsycn  
##### 9#       发表于 2025-8-27 10:36

看了一眼是 2019 年的一篇文章，这两天似乎又被到处转来转去..但我不理解这个术语有什么特别的。
一方面，从微架构角度来说，所有的状态都是由寄存器保存。
另一方面，从 ISA 视角来看，我们从上面那些状态中抽象出体系结构状态暴露给软件，比如 ARM 叫 Special-purpose registers，RISC-V 叫 Control and Status Register。这本质只是命名区别而已..
而且其实你也很难良好地定义 GPR 和这些所谓 Special 的寄存器的区别。因为无论从硬件还是软件的视角来看，他们都只是微结构状态/体系结构状态的一部分。

*****

####  unlsycn  
##### 10#       发表于 2025-8-27 10:48

 本帖最后由 unlsycn 于 2025-8-27 10:53 编辑 

又读了两遍文章。我觉得在它所举的后面那些例子中所谓的 Special Register Groups 和最开始的定义指代的已经不是一个结构了。但是文章本身还是有道理的，所有的术语都只有在特定 context 下才有意义，这个词本身能被沿用这么多年大概确实不是因为它定义得多准确..

*****

####  henvelleng  
##### 11#       发表于 2025-8-27 11:16

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327725&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 10:48</a>

又读了两遍文章。我觉得在它所举的后面那些例子中所谓的 Special Register Groups 和最开始的定义指代的已 ...</blockquote>
以arm为例，cpsr和spsr的作用，依然是和文中的“特殊寄存器组”类似，而且也是组啊，用于cpu切换模式的时候完整保存各模式状态和运算结果的寄存器。

当然一大堆协处理器的寄存器和指令算不算特殊寄存器我就不知道了，应该不算吧

*****

####  unlsycn  
##### 12#       发表于 2025-8-27 11:23

 本帖最后由 unlsycn 于 2025-8-27 11:25 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327914&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 11:16</a>
以arm为例，cpsr和spsr的作用，依然是和文中的“特殊寄存器组”类似，而且也是组啊，用于cpu切换模式的时 ...</blockquote>
Honeywell 的那个设计类似硬件支持的 Context Switch，和现在说的 CSR 还是有显著区别的。
现在的 Context Switch，GPR 和 CSR 是要压栈的。

*****

####  tsubasa9  
##### 13#       发表于 2025-8-27 11:27

寄存器怎么不是cpu的一部分了？你家cpu算加法不用存进位？

这种垃圾ai文能不能别来污染环境

*****

####  oyss  
##### 14#       发表于 2025-8-27 11:30

 本帖最后由 oyss 于 2025-8-27 11:32 编辑 
<blockquote>存储器不是 CPU 的一部分</blockquote>
这里少个图.是字典解释CPU的截图.

他说的存储器是storage

*****

####  henvelleng  
##### 15#       发表于 2025-8-27 11:31

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327948&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 11:23</a>

Honeywell 的那个设计类似硬件支持的 Context Switch，和现在说的 CSR 还是有显著区别的。

现在的 Contex ...</blockquote>
功能类似，就没有改名的必要，你不能要求现在的cpu去一比一照搬远古时代的设计

*****

####  midearth  
##### 16#       发表于 2025-8-27 11:31

等等，现在的cpu已经没有寄存器了吗？

*****

####  henvelleng  
##### 17#       发表于 2025-8-27 12:06

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327988&amp;ptid=2260311" target="_blank">oyss 发表于 2025-8-27 11:30</a>

这里少个图.是字典解释CPU的截图.

他说的存储器是storage</blockquote>
这个main storage指的是霍尼韦尔800里的magnetic core memory吧，可以按word寻址，没用过，应该和现在的cpu从片内memory加载指令进指令寄存器执行应该是一样的，但是现在无论是sram还是nor flash，确实都不在cpu里，而是SoC里了。cpu一般只有cache memory

*****

####  泰坦失足  
##### 18#         楼主| 发表于 2025-8-27 12:16

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327967&amp;ptid=2260311" target="_blank">tsubasa9 发表于 2025-8-27 11:27</a>

寄存器怎么不是cpu的一部分了？你家cpu算加法不用存进位？

这种垃圾ai文能不能别来污染环境 ...</blockquote>
这是19年的文章

*****

####  Jet.Black  
##### 19#       发表于 2025-8-27 14:49

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68328240&amp;ptid=2260311" target="_blank">泰坦失足 发表于 2025-8-27 12:16</a>

这是19年的文章</blockquote>
19年的文章转来干啥，逗网友开心？

*****

####  unlsycn  
##### 20#       发表于 2025-8-27 17:46

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327993&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 11:31</a>
功能类似，就没有改名的必要，你不能要求现在的cpu去一比一照搬远古时代的设计 ...</blockquote>
不不..功能完全不一样啊..
硬件 Context Switch 是完全不同的设计

*****

####  oyss  
##### 21#       发表于 2025-8-27 17:52

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68328187&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 12:06</a>

这个main storage指的是霍尼韦尔800里的magnetic core memory吧，可以按word寻址，没用过，应该和现在的c ...</blockquote>
作者感到奇怪当然是按现在的术语奇怪的.

*****

####  henvelleng  
##### 22#       发表于 2025-8-27 18:07

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68329786&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 17:46</a>
不不..功能完全不一样啊..
硬件 Context Switch 是完全不同的设计</blockquote>
现代cpu的机制变了，不可能出现你说的进程上下文切换放在cpu里操作啊。正常情况下，这部分功能需要有mmu内存管理器来参与，给每个进程提供虚拟地址，才能实现普通人认知概念里的进程切换。当然进程也可以不依赖mmu，没有虚拟地址，但是也必须有mpu。

现代cpu，cpsr spsr是进行模式切换的上下文状态保存的，更直接点，是用来实现操作系统的内核态和应用态的切换的。现代cpu是不可能和远古机器使用同一个机制的

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 23#       发表于 2025-8-27 20:29

 本帖最后由 unlsycn 于 2025-8-27 20:35 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68329893&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 18:07</a>
现代cpu的机制变了，不可能出现你说的进程上下文切换放在cpu里操作啊。正常情况下，这部分功能需要有mmu ...</blockquote>
？？？大哥，你没做过实际的体系结构设计吧...上下文切换当然是 CPU 执行的...mmu是 CPU 的一部分啊。。。
或者展开说，现代的上下文切换是操作系统软件实现的，不依赖于 CPU 的硬件实现，只是把当前的寄存器压栈而已。甚至在一些现代 ISA 下，特权级的切换也是软件实现的，CSR 只是用来存返回地址这种体系结构状态，但是这个保存对软件是可见的。
而主楼提到的机制更类似硬件实现的上下文切换，每个上下文分别保存在不同的硬件reg中，是完全不同的设计啊。。

*****

####  henvelleng  
##### 24#       发表于 2025-8-27 21:04

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330479&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 20:29</a>

？？？大哥，你没做过实际的体系结构设计吧...上下文切换当然是 CPU 执行的...mmu是 CPU 的一部分啊。。 ...</blockquote>
还是以arm为例，通用寄存器r0-r12中，r4-r12在很多cpu模式下是各模式独立的，并非共享，r0-r3是因为用来传递函数参数才公用的，剩下的r13即栈指针sp，r14即变址寄存器lr，r15即程序计数器pc。

这r0-r15里面，只有r15 pc是cpu硬件自动操作的，其他都是要通过代码来手动操作，包括cpsr中的位，同样是部分自动部分手动的。

我不太明白和文中描述的霍尼韦尔800的

   “special register group”，即其各自独立的一组 32 个寄存器（程序计数器、通用寄存器、变址寄存器等）

   

有什么本质区别，从寄存器的名字、功能上来看，都一样啊，一定要纠结是cpu自动操作还是半自动还是代码手动操作吗？虽然我没用过霍尼韦尔800，但是arm  cpu的底层启动代码，我当年手打了很多，甚至一度出于教学目的，用arm 汇编写过不少演示mmu地址映射和保护机制的代码。

*****

####  citrus  
##### 25#       发表于 2025-8-27 21:06

有点像超线程的前身嘛

*****

####  unlsycn  
##### 26#       发表于 2025-8-27 21:09

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330631&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:04</a>
还是以arm为例，通用寄存器r0-r12中，r4-r12在很多cpu模式下是各模式独立的，并非共享，r0-r3是因为用来 ...</blockquote>
本质区别是，现代处理器上下文切换时，寄存器<strong>由软件</strong>被保存到 <strong>memory</strong> 中。
而主楼的设计是<strong>由硬件</strong>保存到核内<strong>独立的reg中</strong>，这里的独立指的是对不同进程相互独立。

*****

####  加油牛油果  
##### 27#       发表于 2025-8-27 21:11

借贴问下手机运营商网络在ios里为什么叫蜂窝网络

*****

####  unlsycn  
##### 28#       发表于 2025-8-27 21:18

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330631&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:04</a>
还是以arm为例，通用寄存器r0-r12中，r4-r12在很多cpu模式下是各模式独立的，并非共享，r0-r3是因为用来 ...</blockquote><blockquote>一定要纠结是cpu自动操作还是半自动还是代码手动操作吗</blockquote>需要，因为是否对软件可见是 ABI 上的区别。
<blockquote>从寄存器的名字、功能上来看，都一样啊</blockquote>完全不一样，主楼这个看上去可以简单认为是多组 GPR。而后来 special register 这个名字则是代指 CSR，但是和 groups 就完全扯不上关系了。当然，就像我在这楼下第一条帖子说的一样，GPR 和 CSR 都是软件可见的体系结构状态，很难精确指出其本质上的分界。但是很显然各个 ISA 都是对它们是完全区分开定义的。

*****

####  unlsycn  
##### 29#       发表于 2025-8-27 21:19

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330631&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:04</a>
还是以arm为例，通用寄存器r0-r12中，r4-r12在很多cpu模式下是各模式独立的，并非共享，r0-r3是因为用来 ...</blockquote>
另外我推荐您再详细看一下看一下你引用的我这条回复，我觉得我已经把你所说的「功能上的区别」说得非常清楚了<img src="https://static.stage1st.com/image/smiley/face2017/068.png" referrerpolicy="no-referrer">

*****

####  henvelleng  
##### 30#       发表于 2025-8-27 21:31

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330682&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 21:18</a>
需要，因为是否对软件可见是 ABI 上的区别。</blockquote>
这些寄存器操作只能使用汇编，而且很多还是协处理器的指令，比如mmu，并不面向高级语言的abi，在os里通常是用内嵌汇编形式调用，或者把汇编封装成c函数来调用的。

如果mmu这种协处理器算cpu的话，感觉就有点混乱了，cpu带的东西会不会太多了。

如果你坚持主楼描述的cpu因为只有远古形态的进程切换，没有面向现代os的模式切换，所以它定义的特殊寄存器，不可能在现代出现，所以现代cpu不可以使用特殊寄存器这个名字的话。。。呃，怎么说呢，那你是对的。

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  革萌  
##### 31#       发表于 2025-8-27 21:32

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327725&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 10:48</a>

又读了两遍文章。我觉得在它所举的后面那些例子中所谓的 Special Register Groups 和最开始的定义指代的已 ...</blockquote>
可以看原始连接，这篇首先说的是当年的CPU里的Unit是个大柜子，里面有主存，算术单元，还有特殊寄存器组。现在CPU变成芯片了，其他概念也变了。

*****

####  henvelleng  
##### 32#       发表于 2025-8-27 21:33

 本帖最后由 henvelleng 于 2025-8-27 21:36 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330695&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 21:19</a>
另外我推荐您再详细看一下看一下你引用的我这条回复，我觉得我已经把你所说的「功能上的区别」说得非常清 ...</blockquote>
其实我一开始就说的很明白了，功能上一定不可能完全一样，前后差了几十年了

“硬件实现的上下文切换”，现代cpu的模式切换，也是硬件实现的（系统调用是指令触发，但切换过程是硬件实现的），也是上下文切换啊，为啥就局限在进程切换了呢。

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 33#       发表于 2025-8-27 21:41

 本帖最后由 unlsycn 于 2025-8-27 21:49 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330743&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:31</a>
这些寄存器操作只能使用汇编，而且很多还是协处理器的指令，比如mmu，并不面向高级语言的abi，在os里通常 ...</blockquote><blockquote>如果mmu这种协处理器算cpu的话</blockquote>鉴于你对我的第一条回复就是以「现代cpu的机制变了」开头，我建议你再去随便找本<strong>现代</strong>体系结构教材，或者随便哪个<strong>现代</strong>CPU架构图，你就会发现你这句话只能暴露你对<strong>现代</strong>体系结构似乎一无所知..

*****

####  henvelleng  
##### 34#       发表于 2025-8-27 21:43

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330648&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 21:09</a>
本质区别是，现代处理器上下文切换时，寄存器由软件被保存到 memory 中。
而主楼的设计是由硬件保存到核 ...</blockquote>
其实要抬杠的话，现代允许并发执行进程的多核cpu，每个核的mmu也是独立的，哈哈哈

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 35#       发表于 2025-8-27 21:48

 本帖最后由 unlsycn 于 2025-8-27 21:51 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330750&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:33</a>
其实我一开始就说的很明白了，功能上一定不可能完全一样，前后差了几十年了

“硬件实现的上下文切换”， ...</blockquote>
因为在这里，它把保存上下文的硬件寄存器叫作 special reg groups，而现代体系结构中上下文根本不在核内保存啊..所以和现在所说的 special regs 完全没有半毛钱关系（现在的说 special regs 一般指的是所我一开始提到的 Special-purpose registers 或者 Control and Status Register，除了 GPR 之外的其他软件可见体系结构状态都算在里面）。。。主楼的文章其实指的就是这个术语的变迁问题...

*****

####  henvelleng  
##### 36#       发表于 2025-8-27 21:51

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330778&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 21:41</a>
鉴于你对我的第一条回复就是以「现代cpu的机制变了」开头，我建议你再去随便找本现代体系结构教材，或者 ...</blockquote>
操作mmu的指令是协处理器指令，当然每代cpu都会有很大变化，指令和功能都会有变化。一般情况下没有人会去写操作mmu的指令，但我真写过
<img src="https://p.sda1.dev/26/41f7b80a11bf910e02815b204ab1b402/image.jpg" referrerpolicy="no-referrer">

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  henvelleng  
##### 37#       发表于 2025-8-27 21:55

 本帖最后由 henvelleng 于 2025-8-27 21:59 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330801&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 21:48</a>
因为在这里，它把保存上下文的硬件寄存器叫作 special reg groups，而现代体系结构中上下文根本不在核内 ...</blockquote>
我前面举的例子里，r0-r12是通用寄存器，随便你放什么数据，而r13-r15这三个就已经是特殊功能寄存器了，cpu会自动操作，不可以用作其他用途，而这三里其中两个，就是主楼文章里提到的程序寄存器和变址寄存器。

至于上下文是不是压栈，对不起，这取决于写程序的人，写单片机的人，写操作系统的人怎么想，和cpu没有半毛钱关系，你大可以把上下文放在r4-r12里啊，我就是这么做的，cpu上电的时候连内存都没有初始化，我上哪里去压栈啊

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 38#       发表于 2025-8-27 22:00

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330810&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:51</a>
操作mmu的指令是协处理器指令，当然每代cpu都会有很大变化，指令和功能都会有变化。一般情况下没有人会去 ...</blockquote>
我大概理解你的问题了<img src="https://static.stage1st.com/image/smiley/face2017/068.png" referrerpolicy="no-referrer">老哥是只写过嵌入式吧，可能不理解体系结构视角。实际上你思考这样一个问题，CPU 的行为是由ISA 定义的，所以在软件看来，mmu就是CPU的一部分，嵌入式场景下把它拆成协处理器实现当然是可能的。但是你看正经 CPU，比如你觉得下图中 AGU 和 TLB 是干啥的..<img src="https://p.sda1.dev/26/9c43b55263e1cfd258ed948095378a34/image.jpg" referrerpolicy="no-referrer">

*****

####  henvelleng  
##### 39#       发表于 2025-8-27 22:11

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330844&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 22:00</a>
我大概理解你的问题了老哥是只写过嵌入式吧，可能不理解体系结构视角。实际上你思考这样一个问题，CPU 的 ...</blockquote>
我非常清楚mmu是如何工作的，不光写过代码，甚至有段时间还反反复复给人培训地址多级映射的原理，然而我并不认为mmu属于cpu，我也不认为x86就是cpu正统

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 40#       发表于 2025-8-27 22:16

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330881&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 22:11</a>
我非常清楚mmu是如何工作的，不光写过代码，甚至有段时间还反反复复给人培训地址多级映射的原理，然而我 ...</blockquote>
你要这样说..我也设计过CPU..
你觉得x86不行可以其实无所谓，因为你可以去读随便 ARM, MIPS, RISCV 的 spec 理解一下什么是 ISA 定义的 CPU..


*****

####  unlsycn  
##### 41#       发表于 2025-8-27 22:16

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330823&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:55</a>
我前面举的例子里，r0-r12是通用寄存器，随便你放什么数据，而r13-r15这三个就已经是特殊功能寄存器了，c ...</blockquote><blockquote>至于上下文是不是压栈，对不起，这取决于写程序的人，写单片机的人，写操作系统的人怎么想，和cpu没有半毛钱关系</blockquote>其实这取决于设计ISA的人..

*****

####  unlsycn  
##### 42#       发表于 2025-8-27 22:20

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330823&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 21:55</a>
我前面举的例子里，r0-r12是通用寄存器，随便你放什么数据，而r13-r15这三个就已经是特殊功能寄存器了，c ...</blockquote>
这里的问题是CPU核内有没有这样一个硬件结构去保存<strong>线程独立</strong>的上下文，我记得我前面已经强调过这个词了....
而且我还反复强调，主楼说的 special reg groups 和现在所说的 special reg 或者其他什么叫法没有一丝一毫的关联。。。我觉得你如果不能理解这个那确实不知道该怎么讨论了...


*****

####  unlsycn  
##### 43#       发表于 2025-8-27 22:25

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327914&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 11:16</a>
以arm为例，cpsr和spsr的作用，依然是和文中的“特殊寄存器组”类似，而且也是组啊，用于cpu切换模式的时 ...</blockquote>
我觉得后面的讨论都绕远了，就从你第一条回复所说。cpsr 和 spsr 保存的是处理器的体系结构状态，对应到其他ISA比如 RISCV 就是 [ms]status，而主楼的所谓 special regs groups 保存的是包括 gpr 在内的，会在上下文切换时被切换掉的数据。这完全不是一回事啊


*****

####  unlsycn  
##### 44#       发表于 2025-8-27 22:28

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330644&amp;ptid=2260311" target="_blank">citrus 发表于 2025-8-27 21:06</a>
有点像超线程的前身嘛</blockquote>
不一样，超线程是一份硬件模拟并行多个线程。主楼的结构是多份寄存器，但是处理器核心本身同时只执行一个进程，只是利用这个结构来实现上下文的切换。


*****

####  unlsycn  
##### 45#       发表于 2025-8-27 22:35

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68327995&amp;ptid=2260311" target="_blank">midearth 发表于 2025-8-27 11:31</a>
等等，现在的cpu已经没有寄存器了吗？</blockquote>
当然有，你参考我第一条回帖。
简单理解的话，从硬件视角来看，在处理器微结构中，所有时序电路都可以认为是由寄存器实现的，所以其实电路中有成千上万个寄存器。
但是实际从软件视角来看，一般所说的寄存器，其实是硬件暴露给软件可见的一系列<strong>状态的集合</strong>，软件不关心他们在硬件上是如何实现的（比如一个状态寄存器背后对应的可能是一个由大量硬件构成的状态机）。
而定义硬件应该暴露哪些状态给软件，这些状态应该表现出什么样的行为的标准就叫作 ISA。


*****

####  henvelleng  
##### 46#       发表于 2025-8-27 22:40

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330922&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 22:25</a>
我觉得后面的讨论都绕远了，就从你第一条回复所说。cpsr 和 spsr 保存的是处理器的体系结构状态，对应到 ...</blockquote>
arm里的r4-r15，也是各模式独立的，在模式切换时，并不会被覆盖掉。切换回原模式时，可以拿回原值。

我换个说法，假设现代cpu不具备模式切换，主楼的cpu也只允许一个进程，只有一套寄存器，那么我的问题是，这个时候这些cpu还有没有所谓特殊寄存器？

你的观点是：没有，特殊寄存器就是用于上下文切换的，没有上下文切换，就不存在特殊寄存器。主楼的文章也是这么认为的，只有成多组的，用于上下文切换的，才是特殊寄存器，这里面甚至包括了通用寄存器。

我的观点是：有，比如r13，r14，r15，它们本身就是特殊功能寄存器，所谓特殊，就是有别于通用寄存器，它们的功能已经被cpu的汇编指令绑架，不能用于通用计算，且文中的远古cpu中的这些寄存器，名字和用法和现代寄存器并无不同。我认为主楼的文章从根本上误解了特殊寄存器的含义，把cpu本身狭义上的进程切换机制，绑架到sp，lr，pc这些沿用至今的寄存器功能上。当然，也可能是我理解错了。

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

*****

####  unlsycn  
##### 47#       发表于 2025-8-27 22:42

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330748&amp;ptid=2260311" target="_blank">革萌 发表于 2025-8-27 21:32</a>
可以看原始连接，这篇首先说的是当年的CPU里的Unit是个大柜子，里面有主存，算术单元，还有特殊寄存器组 ...</blockquote>
是的，硬件实现变了，但是并不是所有的结构都能在现代 CPU 设计中找到对应。
比如很显然 GPR 这个概念就能找到对应，而现代 ISA 的 special purpose regs，虽然在那个年代可能没有被良好定义，但是也是一直都存在的。
而主楼说的这个设计，其实在其他部分架构中也可能昙花一现过，但是显然在常规的架构设计中是完完全全不存在了，更遑论用这个来定义 CPU 的结构了。


*****

####  unlsycn  
##### 48#       发表于 2025-8-27 22:49

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330968&amp;ptid=2260311" target="_blank">henvelleng 发表于 2025-8-27 22:40</a>
arm里的r4-r15，也是各模式独立的，在模式切换时，并不会被覆盖掉。切换回原模式时，可以拿回原值。

我 ...</blockquote>
对，那我们就按你举的例子来讨论。
你说的 r4-r15，在 ARM 的定义中就是 GPR（见 https://developer.arm.com/documentation/dui0473/latest/overview-of-the-arm-architecture/general-purpose-registers）
而 ARM 的 GPR 在上下文切换的时候去哪了呢？答案是保存在了栈中，也就是 memory 里，原文是<blockquote>Each time an interrupt occurs, the µHAL interrupt handling code uHALir_TrapIRQ() saves the current register set on the stack
来源 https://developer.arm.com/documentation/dui0102/g/ch04s02s03</blockquote>
当然，比起上面给软件开发者看的文档，我更推荐老哥去读一下面向体系结构设计的 spec，可能会有更清晰的认识。可以直接搜Arm Architecture Reference Manual，我手机码字就不方便引用了。


*****

####  unlsycn  
##### 49#       发表于 2025-8-27 22:58

 本帖最后由 unlsycn 于 2025-8-27 23:00 编辑 
<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330991&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 22:49</a>
对，那我们就按你举的例子来讨论。
你说的 r4-r15，在 ARM 的定义中就是 GPR和PC，SP，LR，而他们本质都 ...</blockquote>
然后就回到我最开始回答你的所谓「本质区别」，即主楼的设计是将这些 per process 的 context 保存在了核内的 reg groups 中，不同的 group 是独立的，按 process 分开的。
而你举的例子里，你不同线程的状态/上下文在硬件中是保存在相同的硬件寄存器中，虽然在乱序设计中我们可能会有更多的硬件结构（即寄存器重命名），但是这些硬件都是针对当前线程的，在上下文切换时都要从 memory 交换数据。
不知道这样说你有没有更理解一些。


*****

####  henvelleng  
##### 50#       发表于 2025-8-27 23:36

<blockquote><a href="httphttps://stage1st.com/2b/forum.php?mod=redirect&amp;goto=findpost&amp;pid=68330991&amp;ptid=2260311" target="_blank">unlsycn 发表于 2025-8-27 22:49</a>
对，那我们就按你举的例子来讨论。
你说的 r4-r15，在 ARM 的定义中就是 GPR和PC，SP，LR，而他们本质都 ...</blockquote>
我回头看了下资料，果然年代久远有点东西记错了。其实只有sp和lr是各模式独享，而通用寄存器里只有r8-r12是快速中断模式独享，其他都是共享，所以模式切换时才要压栈。

当然，现代cpu下操作系统的进程调度机制不可能和文中的远古cpu有一丝一毫的关系，这是共识。

我又看了一遍原文，文中列出的cpu四大组成，感觉都有点问题，和现代cpu架构格格不入，并不能因为现在的cpu手册里也有特殊功能寄存器的定义，就把它们和文中说的东西联系起来，是我的错。

比如文中说的主存，现代cpu内部是不可能再有可以直接寻址执行代码的存储器的，一定会踢出cpu。原文下面也有评论说一直以为特殊寄存器就是指sp，lr，pc这些通用寄存器以外的寄存器，跟我之前的想法一样。

—— 来自 Xiaomi 23117RK66C, Android 15, [鹅球](https://www.pgyer.com/GcUxKd4w) v3.5.99

